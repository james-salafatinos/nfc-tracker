<script>

        var origin_heat = [480, 250], j = 7, points = [], alpha = 25, beta = 0, startAngle = Math.PI/4;
        var svg_heat    = d3.select('#scatter').append('svg').call(d3.drag().on('drag', dragged).on('start', dragStart).on('end', dragEnd)).append('g');
        var mx, my, mouseX, mouseY;
    
        var surface_heat = d3._3d()
            .scale(10)
            .x(function(d){ return d.x; })
            .y(function(d){ return d.y; })
            .z(function(d){ return d.z; })
            .origin(origin_heat)
            .rotateY(startAngle)
            .rotateX(-startAngle)
            .shape('SURFACE', j*2);
    
        var color_heat = d3.scaleLinear().domain([1,3]);
    
        function processData_heat(data, tt){
    
            var planes = svg_heat.selectAll('path').data(data, function(d){ return d.plane; });
    
            planes
                .enter()
                .append('path')
                .attr('class', '_3d')
                .attr('fill', colorize)
                .attr('opacity', 0)
                .attr('stroke-opacity', 1)
                .merge(planes)
                .attr('stroke', 'black')
                .transition().duration(tt)
                .attr('opacity', 1)
                .attr('fill', colorize)
                .attr('d', surface_heat.draw);
    
            planes.exit().remove();
            
            //d3.selectAll('._3d').sort(d3._3d().sort);
    
        }
    
        function colorize(d){
            var _y = (d[0].y + d[1].y + d[2].y + d[3].y)/4;
            return d.ccw ? d3.interpolateSpectral(color_heat(_y)) : d3.color(d3.interpolateSpectral(color_heat(_y))).darker(1.5);
        }
    
        function dragStart(){
            mx = d3.event.x;
            my = d3.event.y;
        }
    
        function dragged(){
            mouseX = mouseX || 0;
            mouseY = mouseY || 0;
            beta   = (d3.event.x - mx + mouseX) * Math.PI / 230 ;
            alpha  = (d3.event.y - my + mouseY) * Math.PI / 230  * (-1);
            processData_heat(surface_heat.rotateY(beta + startAngle).rotateX(alpha - startAngle)(points), 0);
        }
    
        function dragEnd(){
            mouseX = d3.event.x - mx + mouseX;
            mouseY = d3.event.y - my + mouseY;
        }
    
        function init_heat(eq){
            points = [];
    
            for(var z = -j; z < j; z++){
                for(var x = -j; x < j; x++){
                    points.push({x: x, y: eq(x, z), z: z});
                }
            }
    
            var yMin = d3.min(points, function(d){ return d.y; });
            var yMax = d3.max(points, function(d){ return d.y; });
    
            color.domain([yMin, yMax]);
            processData_heat(surface_heat(points), 100);
        }
        
        var change_cnt = 0
        function change(){
            var rn1 = Math.floor(d3.randomUniform(1, 12)());
            console.log(rn1)
            
           
            function even(x,z) {
                if ((x%2==0) && (z%2==0)){
                    return d3.randomNormal(5,3)()
                } else{
                    return 0
                }
            }
            var eqa = function(x, z){
                return d3.randomNormal(5,3)()//even(x,z)//Math.cos(Math.sqrt(x*x+z*z)/5*Math.PI)*rn1;
            };
            init_heat(eqa);
        }
    

        change();
    
    </script>